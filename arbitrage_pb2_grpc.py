# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
import grpc

import arbitrage_pb2 as arbitrage__pb2


class ArbitrageServiceStub(object):
  """
  Arbitrage service. The general idea of the arbitrage is to buy at lower price
  and sell at high price. We can do this by watching over two exchanges for a
  price of a specific trading pair. If the price differs more than a defined
  gap, the algorithm should execute a trade command for a specific amount.

  The general rule of thumb for selecting an exchange for a trading pair is
  selecting an exchange that has the highest trading volume for that pair and
  exchange that has a moderate trading volume. Because the price of more massive
  exchange usually goes up or down first. Then, when the price is going up, we
  arbitrage on smaller exchange to gain profit.


  """

  def __init__(self, channel):
    """Constructor.

    Args:
      channel: A grpc.Channel.
    """
    self.Initialize = channel.unary_unary(
        '/trading.arbitrage.ArbitrageService/Initialize',
        request_serializer=arbitrage__pb2.InitializeRequest.SerializeToString,
        response_deserializer=arbitrage__pb2.InitializeResponse.FromString,
        )
    self.HandleData = channel.unary_unary(
        '/trading.arbitrage.ArbitrageService/HandleData',
        request_serializer=arbitrage__pb2.HandleDataRequest.SerializeToString,
        response_deserializer=arbitrage__pb2.HandleDataResponse.FromString,
        )
    self.Analysis = channel.unary_unary(
        '/trading.arbitrage.ArbitrageService/Analysis',
        request_serializer=arbitrage__pb2.AnalysisRequest.SerializeToString,
        response_deserializer=arbitrage__pb2.AnalysisResponse.FromString,
        )


class ArbitrageServiceServicer(object):
  """
  Arbitrage service. The general idea of the arbitrage is to buy at lower price
  and sell at high price. We can do this by watching over two exchanges for a
  price of a specific trading pair. If the price differs more than a defined
  gap, the algorithm should execute a trade command for a specific amount.

  The general rule of thumb for selecting an exchange for a trading pair is
  selecting an exchange that has the highest trading volume for that pair and
  exchange that has a moderate trading volume. Because the price of more massive
  exchange usually goes up or down first. Then, when the price is going up, we
  arbitrage on smaller exchange to gain profit.


  """

  def Initialize(self, request, context):
    """
    Set up a context for arbitrage. A client should call initialization
    first to prepare a data for trading.


    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def HandleData(self, request, context):
    """
    Handle each price candle. A client should call handle data for each
    price tick that client prefers.


    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def Analysis(self, request, context):
    """
    Analyze trading performance. A client should call analyze after handle
    data is complete for a performance matrix.


    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')


def add_ArbitrageServiceServicer_to_server(servicer, server):
  rpc_method_handlers = {
      'Initialize': grpc.unary_unary_rpc_method_handler(
          servicer.Initialize,
          request_deserializer=arbitrage__pb2.InitializeRequest.FromString,
          response_serializer=arbitrage__pb2.InitializeResponse.SerializeToString,
      ),
      'HandleData': grpc.unary_unary_rpc_method_handler(
          servicer.HandleData,
          request_deserializer=arbitrage__pb2.HandleDataRequest.FromString,
          response_serializer=arbitrage__pb2.HandleDataResponse.SerializeToString,
      ),
      'Analysis': grpc.unary_unary_rpc_method_handler(
          servicer.Analysis,
          request_deserializer=arbitrage__pb2.AnalysisRequest.FromString,
          response_serializer=arbitrage__pb2.AnalysisResponse.SerializeToString,
      ),
  }
  generic_handler = grpc.method_handlers_generic_handler(
      'trading.arbitrage.ArbitrageService', rpc_method_handlers)
  server.add_generic_rpc_handlers((generic_handler,))
